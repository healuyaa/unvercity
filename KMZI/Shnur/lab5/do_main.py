import client, register, counter

number_users = 10

r1 = register.Register()
c1 = client.Client()
co1 = counter.Counter()

r1.public_list_r()

for i in range(number_users):
    id_ = r1.get_uniq_id_c(c1.get_uniq_id(i ** 2 + 1)) # пункт 3
    co1.get_list_cs(r1.send_uniq_id_cs()) # пункт 4
    
    vote1 = c1.gen_name_of_izb() # пункт 5 с...
    c1.gen_send_pair_MB(vote1, id_)
    MB_B = c1.send_end_vote(id_)
    co1.public_M_MB(MB_B) # пункт 5 по...
    
    co1.init_key(c1.send_key_id(id_))    
    co1.find_res(co1.RC5_decrypt(co1.list_M_MB[1][1]))

print(co1.list_res)

# Как всё это запускать?
# Закинуть всё в одну папку, просто чтобы рядом лежало, если будет ругаться на библиотеку, решим проблему, скажу чё пописать, если не получиться то уже на кмзи, допилим, чтобы завелось
#
# Запускать этот файл, остальные просто как библиотеки используюся, у меня она приняла, значит всё файн
#
# Сразу открываем картинку из лабы с нашим алгоритмом(help.png)
# 
# Есть 2 независимые комиссии по голосованию и их подсчёту(регистратор и счётчик)
# 
# Как всё тут работает + параллель из жизни:
# 1. Сначало ходят люди обзванивают квартиры на голосование, типо чтобы были не мёртвые души, а живые тела
# 2. Публикация тех кто может голосовать
# 3. Далее Избиратели регистрируются
# 4. Регистратор деллает уникальные метки для каждого кто зарегистрировался + отсылае уникальные метки счётчику(тут делается шифрование со сдвигом на 7 бит в какую-то сторону, забыл:) )
# 5. Далее избиратель голосует + создаёт шифрованную пару (М, В), где М - метка(id) который создал регистратор, он уникален, и В - это уже сам выбор за кого отдан голос
# 6. Избиратель отсылает счётчику ещё одну пару (М, (М, В)), ну тут всё тоже самое
# 7. Счётчик публикует то что ему пришло из прошлого этапа
# 8. Далее Избиратель отаправляет пару (М, К), где М - тоже самое, а К - секретный ключ, который используется в шифровании RC2, о мы будем делать вид что RC5
# 9. Далее Счётчик публикует то что пришло
# 10. Подсчёт голосов и вывод\
#
# лирическое отступление, мне было влом делать нормальный вывод, можешь его в целом не трогать, там почти всё понятно из того что я написал выше
#
# Касательно вывода... 
#
# Сначало я генерю тех за кого можно голосвать
# first : FBU1K1U5EI
# second : D43PJWQJDN
# third : 9IFEFNAVBG
# fourth : P3QHFY222L
# fifth : 2BRDZECPIG
# Цифары могут отличаться здесь, это нормально
#
# Далее  
# 32 - Уникальная метка М
# (32, 'KeC25Yq3uKxBl7Pe6MpGig==') - уникальная метка М + зашифрованная пара (М, В)
# 
# next
# 32:second - уникальная метка, а затем имя избирателя
#
# full name1 : 1
# full name2 : 2
# full name3 : 5
# full name4 : 10
# full name5 : 17
# full name6 : 26
# full name7 : 37
# full name8 : 50
# full name9 : 65
# full name10 : 82
# Это изначальные люди, типо имя + id(не путать с уникальной меткой, из этого id получается уникальная метка)
# 
# {'first': 0, 'second': 5, 'third': 1, 'fourth': 1, 'fifth': 3}
# ну тут всё понятно, сколько голосов было получено и за кого сколько проголосовали
